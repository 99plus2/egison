;;;;;
;;;;; Design of Egison3
;;;;;

;
; Data which defines how to pattern-match is called `matcher'.
; A mather is defined with a matcher expression.
; A mather expression takes primitive-match-clauses as a type expression of Egison2.
; The type of matcher is `(Matcher <target-type>)'.
; `Matcher' is primitive-pattern-constructor as `\'.
;
(define $integer
  (matcher
    {[,$val []
      {[$tgt (if (eq? val tgt)
                 {[]}
                 {})]}]
     [$ [something]
      {[$tgt {tgt}]}]}))

(define $mod
  (lambda [$m]
    (matcher
      {[,$val []
        {[$tgt (if (eq? (modulo val m) (modulo tgt m))
                   {[]}
                   {})]}]
       [$ [integer]
        {[$tgt {(modulo tgt m)}]}]
       })))

(define $tree
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-tree? a) val tgt)
                   {[]}
                   {})]}]
       [<node $ $> [(tree a) (tree a)]
        {[<node $n1 $n2> {[n1 n2]}]}]
       [<leaf $> [a]
        {[<leaf $x> {[x]}]}]
       [$ [something]
        {[$tgt {tgt}]}]
       }))
       
;
; `function' expression is like `match-lambda' of other languages.
;
(define $list
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-list? a) val tgt)
                   {[]}
                   {})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (list a)]
        {[{$x @$xs} {[x xs]}]
         [_ {}]}]
       [<snoc $ $> [a (list a)]
        {[{@$xs $x} {[x xs]}]
         [_ {}]}]
       [<join ,$hs $> [(list a)]
        {[$tgt (letrec {[$looper (function [(list a) (list a)]
                                   {[[<nil> $ys] {ys}]
                                    [[<cons $x $xs2> <cons ,x $ys2>] (looper xs2 ys2)]
                                    [[_ _] {}]})]}
                 (looper hs tgt))]}]
       [<join $ $> [(list a) (list a)]
        {[$tgt (letrec {[$looper (lambda [$ret $xs $ys]
                                   (match ys (list a)
                                     {[<nil> {@ret [xs {}]}]
                                      [<cons $y $ys2> (looper {@ret [xs ys]} {@xs y} ys2)]}))]}
                 (looper {} {} tgt))]}]
       [<nioj ,$ts $> [(list a)]
        {[$tgt (letrec {[$looper (function [(list a) (list a)]
                                   {[[<nil> $ys] {ys}]
                                    [[<snoc $x $xs2> <snoc ,x $ys2>] (looper xs2 ys2)]
                                    [[_ _] {}]})]}
                 (looper ts tgt))]}]
       [<nioj $ $> [(list a) (list a)]
        {[$tgt (letrec {[$looper (lambda [$ret $xs $ys]
                                   (match ys (list a)
                                     {[<nil> {@ret [xs {}]}]
                                      [<snoc $y $ys2> (looper {[xs ys] @ret} {@xs y} ys2)]}))]}
                 (looper {} {} tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

(define $multiset-default
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-multiset? a) val tgt)
                   {[]}
                   {})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (multiset a)]
        {[$tgt (match-all tgt (list a)
                 [<join $hs <cons $x $ts>> [x {@hs @ts}]])]}]
       [<join ,$xs $> [(multiset a)]
        {[$tgt (letrec {[$looper (function [(multiset a) (multiset a)]
                                   {[[<nil> $tgt2] {[tgt2]}]
                                    [[<cons $x $xs2> <cons ,x $tgt2>] (looper xs2 tgt2)]
                                    [_ {}]})]}
                 (looper xs tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

;
; Definition of multiset is written also as below.
; * pay atterntion around `cons' matcher clauses.
;
(define $multiset-eq
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-multiset? a) val tgt)
                   {[]}
                   {})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ _> [a]
        {[$tgt (unique tgt)]}]
       [<cons ,val $> [(multiset a)]
        {[$tgt (match-all tgt (list a)
                 [<join $hs <cons ,val $ts>> [{@hs @ts}]])]}]
       [<join ,$xs $> [(multiset a)]
        {[$tgt (letrec {[$looper (function [(multiset a) (multiset a)]
                                   {[[<nil> $tgt2] {[tgt2]}]
                                     [[<cons $x $xs2> <cons ,x $tgt2>] (looper xs2 tgt2)]
                                     [_ {}]})]}
                 (looper xs tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

(define $set
  (lambda [$a]
    (matcher
      {[<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ _> [a]
        [$tgt tgt]]
       [<cons _ $> [(set a)]
        [$tgt {tgt}]]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

(define $map
  (lambda [$fn $ls]
    (match ls (list something)
      {[<nil> {}]
       [<cons $x $xs> {(fn x) @(map fn xs)}]})))

(define $remove
  (lambda [$matcher]
    (lambda [$xs $x]
      (match xs (list matcher)
        {[<nil> {}]
         [<cons ,x $rs> rs]
         [<cons $y $rs> {y @((remove a) rs x)}]}))))

(test ((remove (mod 13)) {10 2 14} 1))

(define $match?
  (lambda [$x $y]
    (match [x y] [(data-to-matcher x) (data-to-matcher y)]
      {[[$zs ,zs] #t]
       [_ #f]})))


;;;
;;; Partial evaluation
;;;

;
; e.g. (+ $ 10) => (lambda [$x] (+ x 10))
;      (+3 $2 20 $1) => (lambda [$v1 $v2] (+3 v2 10 v1))
;
((+ $ 10) 5)

((map id $) {1 2 3})

;;
;; predicate pattern
;;

<cons ?(lambda [$x] (lt? x 10)) _>

<cons ?(lt? $ 10) _>

;;;
;;; Pattern-matching examples
;;;

;;
;; pattern function
;;

(define $seq-pat
  (lambda [$pvar $pat]
    <cons pvar (seq-pat-helper pvar pat 1)>))

(define $seq-pat-helper
  (lambda [$pvar $pat $i]
    <cons ,(+ `pvar i) (| (seq-pat-helper pvar (+ i 1)) pat)))

;
; Mah-jong example
;

(define $shuntsu
  (lambda [$pvar $pat]
    <cons (& <num $s $n> pvar)
     <cons <num ,s ,(+ n 1)>
      <cons <num ,s ,(+ n 2)>
       pat>>>))
        
(define $kohtsu
  (lambda [$pvar $pat]
    <cons pvar
     <cons ,`pvar
      <cons ,`pvar
       pat>>>))

(define $twin
  (lambda [$pvar $pat]
    <cons pvar
     <cons ,`pvar
       pat>>))

(define $yaku?
  (function (multiset hai)
    {[(twin $th_1 (| (shuntsu $sh_1 (shuntsu $sh_2 (shuntsu $sh_3 <nil>)))
                     (shuntsu $sh_1 (shuntsu $sh_2 (kohtsu $kh_1 <nil>)))
                     (shuntsu $sh_1 (kohtsu $kh_1 (kohtsu $kh_2 <nil>)))
                     (kohtsu $kh_1 (kohtsu $kh_2 (kohtsu $kh_3 <nil>)))
                     (twin $th_2 (twin $th_3 (twin $th_4 (twin $th_5 (twin $th_6 (twin $th_7 <nil>))))))
                     ))
      #t]
     [_
      #f]}))

;;
;; IO
;;

(define $main
  (lambda [$world $args]
    (do {[$world (write world "input : ")]
         [$world (flush world)]
         [[$world $val] (read world)]
         [$world (write world {@"output : " @(show val) @"\n"})]}
        world)))

(define $read-two-line
  (lambda [$world]
    (do {[[$world $line1] (read-line world)]
         [[$world $line2] (read-line world)]}
        [world {@line1 @line2}])))


;;;
;;; Module system
;;;

;;
;; Very simple module system, for now.
;;

(module $json)

(export {encode decode})

(import json)
