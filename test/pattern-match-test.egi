(test (assert-equal "pattern variable"
        (match 1 something
          {[$x x]})
        1))

(test (assert "value pattern"
        (match 1 integer
          {[,1 #t]})))

(test (assert "and pattern"
        (match {1 2 3} (list integer)
          {[(& <cons ,1 _> <snoc ,3 _>) #t]})))

(test (assert "and pattern"
        (match {1 2 3} (list integer)
          {[(& <cons ,1 _> <cons ,3 _>) #f]
           [_ #t]})))

(test (assert "and pattern"
        (match #t something
          {[(&) #t]})))

(test (assert "or pattern"
        (match {1 2 3} (list integer)
          {[(| <snoc ,1 _> <snoc ,3 _>) #t]})))

(test (assert "or pattern"
        (match {1 2 3} (list integer)
          {[(| <cons ,2 _> <cons ,3 _>) #f]
           [_ #t]})))

(test (assert "or pattern"
        (match #t something
          {[(|) #f]
           [_ #t]})))

(test (assert "predicate pattern"
        (match {1 2 3} (list integer)
          {[<cons ?(eq? 1 $) _> #t]})))

(test (assert "predicate pattern"
        (match {1 2 3} (list integer)
          {[<cons ?(eq? 2 $) _> #f]
           [_ #t]})))

(define $twin
  (pattern-constructor [$pat1 $pat2]
    <cons (& pat1 $x) <cons ,x pat2>>))

(test (assert-equal "pattern constructor call"
        (match {1 1 1 2 3} (list integer)
          {[(twin $n $ns) [n ns]]})
        [1 {1 2 3}]))

(define $repeat
  (pattern-constructor [$pat]
    (| <nil>
       <cons (& pat $x) (repeat ,x)>)))

(test (assert-equal "recursive pattern constructor call"
        (match {1 1 1 1} (list integer)
          {[(repeat $n) n]})
        1))

(define $nat {1 @(map (+ $ 1) nat)})

(test (assert-equal "pairs of 2 natural numbers"
        (take 10 (match-all nat (set integer)
                   [<cons $m <cons $n _>> [m n]]))
        {[1 1] [1 2] [2 1] [1 3] [2 2] [3 1] [1 4] [2 3] [3 2] [4 1]}))

(test (assert-equal "pairs of 2 different natural numbers"
        (take 10 (match-all nat (list integer)
                   [<join _ <cons $m <join _ <cons $n _>>>> [m n]]))
        {[1 2] [1 3] [2 3] [1 4] [2 4] [3 4] [1 5] [2 5] [3 5] [4 5]}))

#|
(define $tree
  (lambda [$a]
    (algebraic-data-matcher
      (| <leaf> <node tree a tree>)))) 

(define $insert
  (lambda [$n $tree]
    (match tree (tree integer)
      {[<leaf> <Node <Leaf> n <Leaf>>]
       [<node $t1 $m $t2>
        (match (compare-integer n m) ordering
          {[<less> <Node (insert n t1) m t2>]
           [<equal> <Node t1 n t2>]
           [<greater> <Node t1 m (insert n t2)>]})]})))

(define $member?
  (lambda [$n $tree]
    (match tree (tree integer)
      {[<leaf> #f]
       [<node $t1 $m $t2>
        (match (compare-integer n m) ordering
          {[<less> (member? n t1)]
           [<equal> #t]
           [<greater> (member? n t2)]})]})))

(test (assert-equal "tree set using algebraic-data-matcher"
        (let {[$t (foldr insert <Leaf> (between 1 10))]}
          [(member? 5 t) (member? 0 t)])
        [#t #f]))
|#
